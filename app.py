# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rhtOJG6mH9jh2pKTCbnSHhcaCnxNj7va
"""

import streamlit as st
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
import joblib

# Define the model class (must match exactly with training)
class HousePriceNN(nn.Module):
    def __init__(self, input_size, hidden_sizes=[512, 256, 128, 64], dropout_rate=0.3):
        super(HousePriceNN, self).__init__()
        layers = []
        layers.append(nn.Linear(input_size, hidden_sizes[0]))
        layers.append(nn.ReLU())
        layers.append(nn.BatchNorm1d(hidden_sizes[0]))
        layers.append(nn.Dropout(dropout_rate))
        for i in range(len(hidden_sizes) - 1):
            layers.append(nn.Linear(hidden_sizes[i], hidden_sizes[i + 1]))
            layers.append(nn.ReLU())
            layers.append(nn.BatchNorm1d(hidden_sizes[i + 1]))
            layers.append(nn.Dropout(dropout_rate))
        layers.append(nn.Linear(hidden_sizes[-1], 1))
        self.network = nn.Sequential(*layers)

    def forward(self, x):
        return self.network(x)

# Load scalers
scaler_X = joblib.load("scaler_X.pkl")
scaler_y = joblib.load("scaler_y.pkl")

# Initialize model and load weights
input_size = scaler_X.mean_.shape[0]  # input features = number of columns
model = HousePriceNN(input_size)
model.load_state_dict(torch.load("model_state_dict.pth", map_location=torch.device("cpu")))
model.eval()

# Streamlit UI
st.title("üè° California House Price Predictor (NN Model)")

# Take user inputs
living_area = st.number_input("Living Area (sqft)", min_value=200.0, max_value=10000.0)
bedrooms = st.number_input("Bedrooms", min_value=0, max_value=10)
bathrooms = st.number_input("Bathrooms", min_value=0, max_value=10)
lot_size = st.number_input("Lot Size (sqft)", 1000, 20000, step=100)
year_built = st.number_input("Year Built", min_value=1900, max_value=2025)
fireplaces = st.number_input("Fireplaces", min_value=0, max_value=5)
parking = st.number_input("Total Parking Spaces", min_value=0, max_value=10)
garage = st.number_input("Garage Spaces", min_value=0, max_value=5)
stories = st.selectbox("Stories", [1, 2, 3])
assoc_fee = st.number_input("Association Fee ($)", min_value=0.0)
dom = st.number_input("Days on Market", min_value=0)
latitude = st.number_input("Latitude", min_value=32.0, max_value=38.0)
longitude = st.number_input("Longitude", min_value=-124.0, max_value=-114.0)

# On predict
if st.button("Predict Price"):
    # Prepare feature vector
    input_data = np.array([[living_area, bedrooms, bathrooms, lot_size, year_built,
                            fireplaces, parking, garage, stories, assoc_fee,
                            dom, latitude, longitude]])

    # Scale features
    X_scaled = scaler_X.transform(input_data)
    X_tensor = torch.FloatTensor(X_scaled)

    # Predict
    with torch.no_grad():
        y_scaled_pred = model(X_tensor).item()
        y_pred = scaler_y.inverse_transform([[y_scaled_pred]])[0][0]

    st.success(f"üí∞ Estimated House Price: ${y_pred:,.2f}")

